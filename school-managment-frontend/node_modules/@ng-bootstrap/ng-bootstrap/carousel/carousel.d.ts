import { AfterContentChecked, AfterContentInit, ChangeDetectorRef, EventEmitter, NgZone, OnDestroy, QueryList, TemplateRef } from '@angular/core';
import { NgbCarouselConfig } from './carousel-config';
/**
 * A directive that wraps the individual carousel slide.
 */
import * as ɵngcc0 from '@angular/core';
export declare class NgbSlide {
    tplRef: TemplateRef<any>;
    /**
     * Slide id that must be unique for the entire document.
     *
     * If not provided, will be generated in the `ngb-slide-xx` format.
     */
    id: string;
    constructor(tplRef: TemplateRef<any>);
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NgbSlide>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NgbSlide, "ng-template[ngbSlide]", never, {
    "id": "id";
}, {}, never>;
}
/**
 * Carousel is a component to easily create and control slideshows.
 *
 * Allows to set intervals, change the way user interacts with the slides and provides a programmatic API.
 */
export declare class NgbCarousel implements AfterContentChecked, AfterContentInit, OnDestroy {
    private _platformId;
    private _ngZone;
    private _cd;
    slides: QueryList<NgbSlide>;
    NgbSlideEventSource: typeof NgbSlideEventSource;
    private _destroy$;
    private _interval$;
    private _mouseHover$;
    private _pauseOnHover$;
    private _pause$;
    private _wrap$;
    /**
     * The slide id that should be displayed **initially**.
     *
     * For subsequent interactions use methods `select()`, `next()`, etc. and the `(slide)` output.
     */
    activeId: string;
    /**
     * Time in milliseconds before the next slide is shown.
     */
    interval: number;
    /**
     * If `true`, will 'wrap' the carousel by switching from the last slide back to the first.
     */
    wrap: boolean;
    /**
     * If `true`, allows to interact with carousel using keyboard 'arrow left' and 'arrow right'.
     */
    keyboard: boolean;
    /**
     * If `true`, will pause slide switching when mouse cursor hovers the slide.
     *
     * @since 2.2.0
     */
    pauseOnHover: boolean;
    /**
     * If `true`, 'previous' and 'next' navigation arrows will be visible on the slide.
     *
     * @since 2.2.0
     */
    showNavigationArrows: boolean;
    /**
     * If `true`, navigation indicators at the bottom of the slide will be visible.
     *
     * @since 2.2.0
     */
    showNavigationIndicators: boolean;
    /**
     * An event emitted right after the slide transition is completed.
     *
     * See [`NgbSlideEvent`](#/components/carousel/api#NgbSlideEvent) for payload details.
     */
    slide: EventEmitter<NgbSlideEvent>;
    constructor(config: NgbCarouselConfig, _platformId: any, _ngZone: NgZone, _cd: ChangeDetectorRef);
    mouseEnter(): void;
    mouseLeave(): void;
    ngAfterContentInit(): void;
    ngAfterContentChecked(): void;
    ngOnDestroy(): void;
    /**
     * Navigates to a slide with the specified identifier.
     */
    select(slideId: string, source?: NgbSlideEventSource): void;
    /**
     * Navigates to the previous slide.
     */
    prev(source?: NgbSlideEventSource): void;
    /**
     * Navigates to the next slide.
     */
    next(source?: NgbSlideEventSource): void;
    /**
     * Pauses cycling through the slides.
     */
    pause(): void;
    /**
     * Restarts cycling through the slides from left to right.
     */
    cycle(): void;
    private _cycleToSelected;
    private _getSlideEventDirection;
    private _getSlideById;
    private _getSlideIdxById;
    private _getNextSlide;
    private _getPrevSlide;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NgbCarousel>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NgbCarousel, "ngb-carousel", ["ngbCarousel"], {
    "interval": "interval";
    "wrap": "wrap";
    "keyboard": "keyboard";
    "pauseOnHover": "pauseOnHover";
    "showNavigationArrows": "showNavigationArrows";
    "showNavigationIndicators": "showNavigationIndicators";
    "activeId": "activeId";
}, {
    "slide": "slide";
}, ["slides"]>;
}
/**
 * A slide change event emitted right after the slide transition is completed.
 */
export interface NgbSlideEvent {
    /**
     * The previous slide id.
     */
    prev: string;
    /**
     * The current slide id.
     */
    current: string;
    /**
     * The slide event direction.
     *
     * Possible values are `'left' | 'right'`.
     */
    direction: NgbSlideEventDirection;
    /**
     * Whether the pause() method was called (and no cycle() call was done afterwards).
     *
     * @since 5.1.0
     */
    paused: boolean;
    /**
     * Source triggering the slide change event.
     *
     * Possible values are `'timer' | 'arrowLeft' | 'arrowRight' | 'indicator'`
     *
     * @since 5.1.0
     */
    source?: NgbSlideEventSource;
}
/**
 * Defines the carousel slide transition direction.
 */
export declare enum NgbSlideEventDirection {
    LEFT,
    RIGHT
}
export declare enum NgbSlideEventSource {
    TIMER = "timer",
    ARROW_LEFT = "arrowLeft",
    ARROW_RIGHT = "arrowRight",
    INDICATOR = "indicator"
}
export declare const NGB_CAROUSEL_DIRECTIVES: (typeof NgbSlide | typeof NgbCarousel)[];

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2Fyb3VzZWwuZC50cyIsInNvdXJjZXMiOlsiY2Fyb3VzZWwuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWZ0ZXJDb250ZW50Q2hlY2tlZCwgQWZ0ZXJDb250ZW50SW5pdCwgQ2hhbmdlRGV0ZWN0b3JSZWYsIEV2ZW50RW1pdHRlciwgTmdab25lLCBPbkRlc3Ryb3ksIFF1ZXJ5TGlzdCwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5nYkNhcm91c2VsQ29uZmlnIH0gZnJvbSAnLi9jYXJvdXNlbC1jb25maWcnO1xuLyoqXG4gKiBBIGRpcmVjdGl2ZSB0aGF0IHdyYXBzIHRoZSBpbmRpdmlkdWFsIGNhcm91c2VsIHNsaWRlLlxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBOZ2JTbGlkZSB7XG4gICAgdHBsUmVmOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIC8qKlxuICAgICAqIFNsaWRlIGlkIHRoYXQgbXVzdCBiZSB1bmlxdWUgZm9yIHRoZSBlbnRpcmUgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBub3QgcHJvdmlkZWQsIHdpbGwgYmUgZ2VuZXJhdGVkIGluIHRoZSBgbmdiLXNsaWRlLXh4YCBmb3JtYXQuXG4gICAgICovXG4gICAgaWQ6IHN0cmluZztcbiAgICBjb25zdHJ1Y3Rvcih0cGxSZWY6IFRlbXBsYXRlUmVmPGFueT4pO1xufVxuLyoqXG4gKiBDYXJvdXNlbCBpcyBhIGNvbXBvbmVudCB0byBlYXNpbHkgY3JlYXRlIGFuZCBjb250cm9sIHNsaWRlc2hvd3MuXG4gKlxuICogQWxsb3dzIHRvIHNldCBpbnRlcnZhbHMsIGNoYW5nZSB0aGUgd2F5IHVzZXIgaW50ZXJhY3RzIHdpdGggdGhlIHNsaWRlcyBhbmQgcHJvdmlkZXMgYSBwcm9ncmFtbWF0aWMgQVBJLlxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBOZ2JDYXJvdXNlbCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudENoZWNrZWQsIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG4gICAgcHJpdmF0ZSBfcGxhdGZvcm1JZDtcbiAgICBwcml2YXRlIF9uZ1pvbmU7XG4gICAgcHJpdmF0ZSBfY2Q7XG4gICAgc2xpZGVzOiBRdWVyeUxpc3Q8TmdiU2xpZGU+O1xuICAgIE5nYlNsaWRlRXZlbnRTb3VyY2U6IHR5cGVvZiBOZ2JTbGlkZUV2ZW50U291cmNlO1xuICAgIHByaXZhdGUgX2Rlc3Ryb3kkO1xuICAgIHByaXZhdGUgX2ludGVydmFsJDtcbiAgICBwcml2YXRlIF9tb3VzZUhvdmVyJDtcbiAgICBwcml2YXRlIF9wYXVzZU9uSG92ZXIkO1xuICAgIHByaXZhdGUgX3BhdXNlJDtcbiAgICBwcml2YXRlIF93cmFwJDtcbiAgICAvKipcbiAgICAgKiBUaGUgc2xpZGUgaWQgdGhhdCBzaG91bGQgYmUgZGlzcGxheWVkICoqaW5pdGlhbGx5KiouXG4gICAgICpcbiAgICAgKiBGb3Igc3Vic2VxdWVudCBpbnRlcmFjdGlvbnMgdXNlIG1ldGhvZHMgYHNlbGVjdCgpYCwgYG5leHQoKWAsIGV0Yy4gYW5kIHRoZSBgKHNsaWRlKWAgb3V0cHV0LlxuICAgICAqL1xuICAgIGFjdGl2ZUlkOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGltZSBpbiBtaWxsaXNlY29uZHMgYmVmb3JlIHRoZSBuZXh0IHNsaWRlIGlzIHNob3duLlxuICAgICAqL1xuICAgIGludGVydmFsOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogSWYgYHRydWVgLCB3aWxsICd3cmFwJyB0aGUgY2Fyb3VzZWwgYnkgc3dpdGNoaW5nIGZyb20gdGhlIGxhc3Qgc2xpZGUgYmFjayB0byB0aGUgZmlyc3QuXG4gICAgICovXG4gICAgd3JhcDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBJZiBgdHJ1ZWAsIGFsbG93cyB0byBpbnRlcmFjdCB3aXRoIGNhcm91c2VsIHVzaW5nIGtleWJvYXJkICdhcnJvdyBsZWZ0JyBhbmQgJ2Fycm93IHJpZ2h0Jy5cbiAgICAgKi9cbiAgICBrZXlib2FyZDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBJZiBgdHJ1ZWAsIHdpbGwgcGF1c2Ugc2xpZGUgc3dpdGNoaW5nIHdoZW4gbW91c2UgY3Vyc29yIGhvdmVycyB0aGUgc2xpZGUuXG4gICAgICpcbiAgICAgKiBAc2luY2UgMi4yLjBcbiAgICAgKi9cbiAgICBwYXVzZU9uSG92ZXI6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogSWYgYHRydWVgLCAncHJldmlvdXMnIGFuZCAnbmV4dCcgbmF2aWdhdGlvbiBhcnJvd3Mgd2lsbCBiZSB2aXNpYmxlIG9uIHRoZSBzbGlkZS5cbiAgICAgKlxuICAgICAqIEBzaW5jZSAyLjIuMFxuICAgICAqL1xuICAgIHNob3dOYXZpZ2F0aW9uQXJyb3dzOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIElmIGB0cnVlYCwgbmF2aWdhdGlvbiBpbmRpY2F0b3JzIGF0IHRoZSBib3R0b20gb2YgdGhlIHNsaWRlIHdpbGwgYmUgdmlzaWJsZS5cbiAgICAgKlxuICAgICAqIEBzaW5jZSAyLjIuMFxuICAgICAqL1xuICAgIHNob3dOYXZpZ2F0aW9uSW5kaWNhdG9yczogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBBbiBldmVudCBlbWl0dGVkIHJpZ2h0IGFmdGVyIHRoZSBzbGlkZSB0cmFuc2l0aW9uIGlzIGNvbXBsZXRlZC5cbiAgICAgKlxuICAgICAqIFNlZSBbYE5nYlNsaWRlRXZlbnRgXSgjL2NvbXBvbmVudHMvY2Fyb3VzZWwvYXBpI05nYlNsaWRlRXZlbnQpIGZvciBwYXlsb2FkIGRldGFpbHMuXG4gICAgICovXG4gICAgc2xpZGU6IEV2ZW50RW1pdHRlcjxOZ2JTbGlkZUV2ZW50PjtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWc6IE5nYkNhcm91c2VsQ29uZmlnLCBfcGxhdGZvcm1JZDogYW55LCBfbmdab25lOiBOZ1pvbmUsIF9jZDogQ2hhbmdlRGV0ZWN0b3JSZWYpO1xuICAgIG1vdXNlRW50ZXIoKTogdm9pZDtcbiAgICBtb3VzZUxlYXZlKCk6IHZvaWQ7XG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQ7XG4gICAgbmdBZnRlckNvbnRlbnRDaGVja2VkKCk6IHZvaWQ7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBOYXZpZ2F0ZXMgdG8gYSBzbGlkZSB3aXRoIHRoZSBzcGVjaWZpZWQgaWRlbnRpZmllci5cbiAgICAgKi9cbiAgICBzZWxlY3Qoc2xpZGVJZDogc3RyaW5nLCBzb3VyY2U/OiBOZ2JTbGlkZUV2ZW50U291cmNlKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBOYXZpZ2F0ZXMgdG8gdGhlIHByZXZpb3VzIHNsaWRlLlxuICAgICAqL1xuICAgIHByZXYoc291cmNlPzogTmdiU2xpZGVFdmVudFNvdXJjZSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogTmF2aWdhdGVzIHRvIHRoZSBuZXh0IHNsaWRlLlxuICAgICAqL1xuICAgIG5leHQoc291cmNlPzogTmdiU2xpZGVFdmVudFNvdXJjZSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogUGF1c2VzIGN5Y2xpbmcgdGhyb3VnaCB0aGUgc2xpZGVzLlxuICAgICAqL1xuICAgIHBhdXNlKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogUmVzdGFydHMgY3ljbGluZyB0aHJvdWdoIHRoZSBzbGlkZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAqL1xuICAgIGN5Y2xlKCk6IHZvaWQ7XG4gICAgcHJpdmF0ZSBfY3ljbGVUb1NlbGVjdGVkO1xuICAgIHByaXZhdGUgX2dldFNsaWRlRXZlbnREaXJlY3Rpb247XG4gICAgcHJpdmF0ZSBfZ2V0U2xpZGVCeUlkO1xuICAgIHByaXZhdGUgX2dldFNsaWRlSWR4QnlJZDtcbiAgICBwcml2YXRlIF9nZXROZXh0U2xpZGU7XG4gICAgcHJpdmF0ZSBfZ2V0UHJldlNsaWRlO1xufVxuLyoqXG4gKiBBIHNsaWRlIGNoYW5nZSBldmVudCBlbWl0dGVkIHJpZ2h0IGFmdGVyIHRoZSBzbGlkZSB0cmFuc2l0aW9uIGlzIGNvbXBsZXRlZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZ2JTbGlkZUV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJldmlvdXMgc2xpZGUgaWQuXG4gICAgICovXG4gICAgcHJldjogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHNsaWRlIGlkLlxuICAgICAqL1xuICAgIGN1cnJlbnQ6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgc2xpZGUgZXZlbnQgZGlyZWN0aW9uLlxuICAgICAqXG4gICAgICogUG9zc2libGUgdmFsdWVzIGFyZSBgJ2xlZnQnIHwgJ3JpZ2h0J2AuXG4gICAgICovXG4gICAgZGlyZWN0aW9uOiBOZ2JTbGlkZUV2ZW50RGlyZWN0aW9uO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHBhdXNlKCkgbWV0aG9kIHdhcyBjYWxsZWQgKGFuZCBubyBjeWNsZSgpIGNhbGwgd2FzIGRvbmUgYWZ0ZXJ3YXJkcykuXG4gICAgICpcbiAgICAgKiBAc2luY2UgNS4xLjBcbiAgICAgKi9cbiAgICBwYXVzZWQ6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU291cmNlIHRyaWdnZXJpbmcgdGhlIHNsaWRlIGNoYW5nZSBldmVudC5cbiAgICAgKlxuICAgICAqIFBvc3NpYmxlIHZhbHVlcyBhcmUgYCd0aW1lcicgfCAnYXJyb3dMZWZ0JyB8ICdhcnJvd1JpZ2h0JyB8ICdpbmRpY2F0b3InYFxuICAgICAqXG4gICAgICogQHNpbmNlIDUuMS4wXG4gICAgICovXG4gICAgc291cmNlPzogTmdiU2xpZGVFdmVudFNvdXJjZTtcbn1cbi8qKlxuICogRGVmaW5lcyB0aGUgY2Fyb3VzZWwgc2xpZGUgdHJhbnNpdGlvbiBkaXJlY3Rpb24uXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGVudW0gTmdiU2xpZGVFdmVudERpcmVjdGlvbiB7XG4gICAgTEVGVCxcbiAgICBSSUdIVFxufVxuZXhwb3J0IGRlY2xhcmUgZW51bSBOZ2JTbGlkZUV2ZW50U291cmNlIHtcbiAgICBUSU1FUiA9IFwidGltZXJcIixcbiAgICBBUlJPV19MRUZUID0gXCJhcnJvd0xlZnRcIixcbiAgICBBUlJPV19SSUdIVCA9IFwiYXJyb3dSaWdodFwiLFxuICAgIElORElDQVRPUiA9IFwiaW5kaWNhdG9yXCJcbn1cbmV4cG9ydCBkZWNsYXJlIGNvbnN0IE5HQl9DQVJPVVNFTF9ESVJFQ1RJVkVTOiAodHlwZW9mIE5nYlNsaWRlIHwgdHlwZW9mIE5nYkNhcm91c2VsKVtdO1xuIl19